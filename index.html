
# ÿ•ŸÜÿ¥ÿßÿ° ŸÑÿπÿ®ÿ© Battle Royale ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ÿßŸÑŸÉÿßŸÖŸÑÿ©
# ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ Ÿäÿ≠ÿ™ŸàŸä ÿπŸÑŸâ ŸÉŸÑ ÿ¥Ÿäÿ°

game_html = '''<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KIM Battle Royale - ŸÑÿπÿ®ÿ© ÿßŸÑÿ®ŸÇÿßÿ° ŸÑŸÑÿ£ŸÇŸàŸâ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Cairo', sans-serif;
        }
        
        body {
            overflow: hidden;
            background: #000;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* ÿßŸÑŸÑŸàÿ®Ÿä ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸä */
        #lobby {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #lobby::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="none" stroke="rgba(255,215,0,0.1)" stroke-width="0.5"/></svg>');
            background-size: 100px 100px;
            animation: bgMove 20s linear infinite;
        }
        
        @keyframes bgMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        .lobby-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 10;
        }
        
        .logo {
            font-size: 42px;
            font-weight: 900;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF6347);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255,215,0,0.5);
            letter-spacing: 2px;
        }
        
        .player-profile {
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 25px;
            border: 1px solid rgba(255,215,0,0.3);
        }
        
        .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: 3px solid #FFD700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }
        
        .lobby-content {
            flex: 1;
            display: flex;
            position: relative;
            z-index: 10;
        }
        
        .character-showcase {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #characterPreview {
            width: 300px;
            height: 400px;
            position: relative;
        }
        
        .skin-selector {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        .skin-card {
            width: 80px;
            height: 80px;
            border-radius: 15px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .skin-card.active {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
            transform: scale(1.1);
        }
        
        .skin-card:hover {
            transform: scale(1.05);
        }
        
        .skin-card.locked::after {
            content: 'üîí';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            background: rgba(0,0,0,0.7);
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .lobby-menu {
            width: 300px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .menu-btn {
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            box-shadow: 0 4px 15px rgba(255,215,0,0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255,215,0,0.6);
        }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .btn-secondary:hover {
            background: rgba(255,255,255,0.2);
            border-color: #FFD700;
        }
        
        .kim-entry {
            position: absolute;
            bottom: 30px;
            left: 30px;
            padding: 20px 40px;
            background: linear-gradient(135deg, #FFD700, #FF8C00);
            border: none;
            border-radius: 50px;
            font-size: 24px;
            font-weight: 900;
            color: #000;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255,215,0,0.5);
            transition: all 0.3s;
            z-index: 100;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .kim-entry:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(255,215,0,0.7);
        }
        
        .kim-entry::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 2px solid #FFD700;
            border-radius: 55px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.1); opacity: 0; }
        }
        
        /* ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-text {
            font-size: 48px;
            color: #FFD700;
            font-weight: 900;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        
        .loading-bar {
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #FFA500);
            width: 0%;
            transition: width 0.3s;
            box-shadow: 0 0 10px #FFD700;
        }
        
        /* ÿßŸÑŸàÿßÿ¨Ÿáÿ© ÿØÿßÿÆŸÑ ÿßŸÑŸÑÿπÿ®ÿ© */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }
        
        .ui-top {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid rgba(255,215,0,0.3);
            backdrop-filter: blur(10px);
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #fff;
            font-weight: 700;
        }
        
        .stat-icon {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
        }
        
        /* ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑÿµÿ∫Ÿäÿ±ÿ© ÿßŸÑÿØÿßÿ¶ÿ±Ÿäÿ© */
        .minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .minimap {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            border: 3px solid #FFD700;
            overflow: hidden;
            position: relative;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }
        
        .minimap-player {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #00ff00;
            z-index: 10;
        }
        
        .minimap-zone {
            position: absolute;
            border: 2px solid rgba(255,0,0,0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* ÿ¥ÿ±Ÿäÿ∑ ÿßŸÑÿµÿ≠ÿ© ŸàÿßŸÑÿØÿ±ÿπ */
        .health-container {
            position: absolute;
            bottom: 120px;
            left: 20px;
            width: 200px;
        }
        
        .bar {
            height: 12px;
            background: rgba(0,0,0,0.6);
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 5px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            width: 100%;
            transition: width 0.3s;
        }
        
        .armor-fill {
            height: 100%;
            background: linear-gradient(90deg, #0080ff, #00ccff);
            width: 100%;
            transition: width 0.3s;
        }
        
        /* ÿßŸÑÿ∞ÿÆŸäÿ±ÿ© */
        .ammo-display {
            position: absolute;
            bottom: 120px;
            right: 20px;
            text-align: center;
        }
        
        .ammo-count {
            font-size: 48px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,0,0,0.8);
        }
        
        .ammo-type {
            font-size: 14px;
            color: #aaa;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 10px;
        }
        
        /* ÿßŸÑÿ¨Ÿàÿ≥ÿ™ŸäŸÉ */
        .joystick-area {
            position: absolute;
            bottom: 100px;
            left: 100px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
        }
        
        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            backdrop-filter: blur(5px);
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,215,0,0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
            transition: transform 0.1s;
        }
        
        /* ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ */
        .control-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.2s;
            backdrop-filter: blur(5px);
        }
        
        .control-btn:active {
            transform: scale(0.95);
            background: rgba(255,215,0,0.3);
        }
        
        .btn-fire {
            bottom: 150px;
            right: 40px;
            width: 90px;
            height: 90px;
            background: rgba(255,0,0,0.3);
            border-color: rgba(255,0,0,0.6);
        }
        
        .btn-aim {
            bottom: 260px;
            right: 40px;
            width: 70px;
            height: 70px;
        }
        
        .btn-jump {
            bottom: 50px;
            right: 140px;
        }
        
        .btn-crouch {
            bottom: 50px;
            right: 230px;
        }
        
        .btn-prone {
            bottom: 50px;
            right: 320px;
        }
        
        .btn-reload {
            bottom: 260px;
            right: 130px;
        }
        
        .btn-switch {
            bottom: 340px;
            right: 40px;
        }
        
        .btn-map {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #FFD700;
            border-radius: 10px;
            pointer-events: auto;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #FFD700;
            font-weight: 900;
        }
        
        /* ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÉÿ®Ÿäÿ±ÿ© */
        #bigMap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            z-index: 500;
            pointer-events: auto;
        }
        
        .map-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255,0,0,0.8);
            border: none;
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            z-index: 501;
        }
        
        /* ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ */
        #settings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 500px;
            background: rgba(0,0,0,0.95);
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 600;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .settings-title {
            font-size: 28px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            font-weight: 900;
        }
        
        .setting-item {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
        }
        
        .setting-label {
            color: #fff;
            margin-bottom: 10px;
            display: block;
            font-weight: 700;
        }
        
        .setting-slider {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            outline: none;
        }
        
        .setting-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #FFD700;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        
        /* ÿ¥ÿßÿ¥ÿ© ÿßŸÑŸÜŸáÿßŸäÿ© */
        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .end-title {
            font-size: 72px;
            font-weight: 900;
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        
        .victory {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px rgba(255,215,0,0.5);
        }
        
        .defeat {
            color: #ff0000;
            text-shadow: 0 0 50px rgba(255,0,0,0.5);
        }
        
        /* ÿßŸÑÿ±ÿµÿßÿµ ÿßŸÑŸÖÿ±ÿ¶Ÿä */
        .bullet-tracer {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255,255,0,0), rgba(255,255,0,1), rgba(255,255,0,0));
            pointer-events: none;
            z-index: 100;
        }
        
        /* ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ */
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #FFD700;
            padding: 15px 30px;
            border-radius: 10px;
            border: 1px solid #FFD700;
            font-weight: 700;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 400;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- ÿßŸÑŸÑŸàÿ®Ÿä -->
    <div id="lobby">
        <div class="lobby-header">
            <div class="logo">KIM ROYALE</div>
            <div class="player-profile">
                <div class="avatar">üë§</div>
                <div style="color: #fff; font-weight: 700;">Mohammed</div>
                <div style="color: #FFD700;">‚òÖ 2500</div>
            </div>
        </div>
        
        <div class="lobby-content">
            <div class="character-showcase">
                <canvas id="characterPreview"></canvas>
                <div class="skin-selector">
                    <div class="skin-card active" data-skin="0" style="background: linear-gradient(135deg, #667eea, #764ba2);"></div>
                    <div class="skin-card" data-skin="1" style="background: linear-gradient(135deg, #f093fb, #f5576c);"></div>
                    <div class="skin-card" data-skin="2" style="background: linear-gradient(135deg, #4facfe, #00f2fe);"></div>
                </div>
            </div>
            
            <div class="lobby-menu">
                <button class="menu-btn btn-primary" onclick="startGame()">ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©</button>
                <button class="menu-btn btn-secondary" onclick="openSettings()">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</button>
                <button class="menu-btn btn-secondary" onclick="showHowToPlay()">ŸÉŸäŸÅŸäÿ© ÿßŸÑŸÑÿπÿ®</button>
            </div>
        </div>
        
        <button class="kim-entry" onclick="enterKimMode()">KIM Entry</button>
    </div>
    
    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ -->
    <div id="loadingScreen">
        <div class="loading-text">KIM ROYALE</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div style="color: #fff; margin-top: 20px; font-size: 18px;">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿπÿ±ŸÉÿ©...</div>
    </div>
    
    <!-- Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÑÿπÿ®ÿ© -->
    <div id="gameUI">
        <div class="ui-top">
            <div class="stat-item">
                <span style="color: #FFD700;">‚ö°</span>
                <span id="playersLeft">16</span>
            </div>
            <div class="stat-item">
                <span style="color: #ff0000;">‚ò†</span>
                <span id="killCount">0</span>
            </div>
            <div class="stat-item">
                <span style="color: #00ff00;">‚è±</span>
                <span id="zoneTimer">60</span>s
            </div>
        </div>
        
        <div class="minimap-container" onclick="toggleBigMap()">
            <div class="minimap">
                <div class="minimap-zone" id="minimapZone" style="width: 100px; height: 100px;"></div>
                <div class="minimap-player"></div>
            </div>
        </div>
        
        <div class="btn-map" onclick="toggleBigMap()">üó∫</div>
        
        <div id="bigMap">
            <button class="map-close" onclick="toggleBigMap()">‚úï</button>
            <canvas id="bigMapCanvas" style="width: 100%; height: 100%;"></canvas>
        </div>
        
        <div class="health-container">
            <div class="bar">
                <div class="health-fill" id="healthBar"></div>
            </div>
            <div class="bar">
                <div class="armor-fill" id="armorBar"></div>
            </div>
        </div>
        
        <div class="ammo-display">
            <div class="ammo-count">
                <span id="currentMag">30</span> / <span id="reserveAmmo">120</span>
            </div>
            <div class="ammo-type" id="weaponName">M416</div>
        </div>
        
        <div class="joystick-area" id="moveJoystick">
            <div class="joystick-base"></div>
            <div class="joystick-knob" id="moveKnob"></div>
        </div>
        
        <div class="control-btn btn-fire" id="fireBtn" ontouchstart="startFiring()" ontouchend="stopFiring()">üî•</div>
        <div class="control-btn btn-aim" id="aimBtn" onclick="toggleAim()">üëÅ</div>
        <div class="control-btn btn-jump" onclick="jump()">‚Üü</div>
        <div class="control-btn btn-crouch" onclick="toggleCrouch()">ü†ó</div>
        <div class="control-btn btn-prone" onclick="toggleProne()">‚¨≥</div>
        <div class="control-btn btn-reload" onclick="reload()">‚Üª</div>
        <div class="control-btn btn-switch" onclick="switchWeapon()">‚áÑ</div>
        
        <div class="notification" id="notification"></div>
    </div>
    
    <!-- ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ -->
    <div id="settings">
        <div class="settings-title">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</div>
        <div class="setting-item">
            <label class="setting-label">ÿ≠ÿ¨ŸÖ ÿßŸÑÿ¨Ÿàÿ≥ÿ™ŸäŸÉ</label>
            <input type="range" class="setting-slider" min="50" max="150" value="100" onchange="updateJoystickSize(this.value)">
        </div>
        <div class="setting-item">
            <label class="setting-label">ÿ≠ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß</label>
            <input type="range" class="setting-slider" min="1" max="10" value="5" onchange="updateSensitivity(this.value)">
        </div>
        <div class="setting-item">
            <label class="setting-label">ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿµÿπŸàÿ®ÿ©</label>
            <select style="width: 100%; padding: 10px; border-radius: 5px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.3);" onchange="setDifficulty(this.value)">
                <option value="easy">ÿ≥ŸáŸÑ</option>
                <option value="medium" selected>ŸÖÿ™Ÿàÿ≥ÿ∑</option>
                <option value="hard">ÿµÿπÿ®</option>
                <option value="expert">ÿÆÿ®Ÿäÿ±</option>
            </select>
        </div>
        <button class="menu-btn btn-primary" onclick="closeSettings()" style="margin-top: 20px;">ÿ≠ŸÅÿ∏</button>
    </div>
    
    <!-- ÿ¥ÿßÿ¥ÿ© ÿßŸÑŸÜŸáÿßŸäÿ© -->
    <div id="endScreen">
        <div class="end-title victory" id="endTitle">ÿßŸÜÿ™ÿµÿ±ÿ™!</div>
        <div style="color: #fff; font-size: 24px; margin-bottom: 30px;">
            ÿßŸÑŸÇÿ™ŸÑ: <span id="endKills">0</span> | ÿßŸÑÿ∂ÿ±ÿ±: <span id="endDamage">0</span>
        </div>
        <button class="menu-btn btn-primary" onclick="location.reload()">ÿßŸÑÿπŸàÿØÿ© ŸÑŸÑŸàÿ®Ÿä</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ŸÜÿ∏ÿßŸÖ ÿßŸÑÿµŸàÿ™ ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸä
        const AudioEngine = {
            ctx: null,
            masterGain: null,
            
            init() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = 0.8;
            },
            
            // ÿµŸàÿ™ ÿ•ÿ∑ŸÑÿßŸÇ ŸÜÿßÿ± ŸàÿßŸÇÿπŸä 100%
            playGunshot(weaponType = 'rifle') {
                if (!this.ctx) return;
                
                const t = this.ctx.currentTime;
                const sounds = [];
                
                // 1. ÿßŸÑÿßŸÜŸÅÿ¨ÿßÿ± ÿßŸÑÿ£ŸàŸÑŸä (initial crack)
                const osc1 = this.ctx.createOscillator();
                const gain1 = this.ctx.createGain();
                osc1.connect(gain1);
                gain1.connect(this.masterGain);
                
                osc1.type = 'sawtooth';
                osc1.frequency.setValueAtTime(800, t);
                osc1.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                gain1.gain.setValueAtTime(0.5, t);
                gain1.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                
                osc1.start(t);
                osc1.stop(t + 0.15);
                
                // 2. ÿßŸÑÿ∂ÿ¨Ÿäÿ¨ (noise burst)
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (this.ctx.sampleRate * 0.05));
                }
                
                const noise = this.ctx.createBufferSource();
                const noiseFilter = this.ctx.createBiquadFilter();
                const noiseGain = this.ctx.createGain();
                
                noise.buffer = buffer;
                noiseFilter.type = 'bandpass';
                noiseFilter.frequency.value = weaponType === 'sniper' ? 2000 : 1000;
                noiseFilter.Q.value = 1;
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                
                noiseGain.gain.setValueAtTime(0.4, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                
                noise.start(t);
                
                // 3. ÿßŸÑÿµÿØŸâ (echo)
                const echoDelay = this.ctx.createDelay();
                const echoGain = this.ctx.createGain();
                echoDelay.delayTime.value = 0.1;
                echoGain.gain.value = 0.3;
                
                noiseFilter.connect(echoDelay);
                echoDelay.connect(echoGain);
                echoGain.connect(this.masterGain);
                
                // 4. ÿ∑ŸÜŸäŸÜ (ringing)
                const osc2 = this.ctx.createOscillator();
                const gain2 = this.ctx.createGain();
                osc2.connect(gain2);
                gain2.connect(this.masterGain);
                
                osc2.type = 'square';
                osc2.frequency.setValueAtTime(200, t);
                osc2.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain2.gain.setValueAtTime(0.1, t);
                gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc2.start(t);
                osc2.stop(t + 0.1);
            },
            
            // ÿÆÿ∑Ÿàÿßÿ™ ŸàÿßŸÇÿπŸäÿ©
            playFootstep(surface = 'grass') {
                if (!this.ctx) return;
                
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                if (surface === 'grass') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(80, t);
                    filter.type = 'lowpass';
                    filter.frequency.value = 200;
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                } else if (surface === 'wood') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(120, t);
                    filter.type = 'bandpass';
                    filter.frequency.value = 400;
                    gain.gain.setValueAtTime(0.08, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);
                } else if (surface === 'water') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, t);
                    filter.type = 'highpass';
                    filter.frequency.value = 300;
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                }
                
                osc.start(t);
                osc.stop(t + 0.15);
            },
            
            // ÿµŸàÿ™ ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
            playReload() {
                if (!this.ctx) return;
                
                const t = this.ctx.currentTime;
                
                // ÿµŸàÿ™ ÿ≥ÿ≠ÿ® ÿßŸÑÿ≥ŸÑÿßÿ≠
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.3);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.3);
                
                osc.start(t);
                osc.stop(t + 0.3);
                
                // ÿµŸàÿ™ ÿ∑ŸÇÿ∑ŸÇÿ©
                setTimeout(() => {
                    const click = this.ctx.createOscillator();
                    const clickGain = this.ctx.createGain();
                    click.connect(clickGain);
                    clickGain.connect(this.masterGain);
                    
                    click.type = 'square';
                    click.frequency.value = 1000;
                    clickGain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                    clickGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                    
                    click.start();
                    click.stop(this.ctx.currentTime + 0.05);
                }, 200);
            },
            
            // ÿµŸàÿ™ ÿßŸÑÿ¨ÿ±Ÿàÿ≠
            playHit() {
                if (!this.ctx) return;
                
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc.start(t);
                osc.stop(t + 0.1);
            },
            
            // ÿµŸàÿ™ ÿ¥ÿ±ÿ® ÿßŸÑÿπŸÑÿßÿ¨
            playHeal() {
                if (!this.ctx) return;
                
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, t);
                osc.frequency.linearRampToValueAtTime(880, t + 0.5);
                gain.gain.setValueAtTime(0.1, t);
                gain.gain.linearRampToValueAtTime(0, t + 0.5);
                
                osc.start(t);
                osc.stop(t + 0.5);
            },
            
            // ŸÖŸàÿ≥ŸäŸÇŸâ ÿßŸÑŸÑŸàÿ®Ÿä
            playLobbyMusic() {
                if (!this.ctx) return;
                
                // ŸÜÿ∫ŸÖÿ© ÿ®ÿ≥Ÿäÿ∑ÿ© ÿ≠ŸÑŸÇÿ©
                const notes = [220, 261.63, 329.63, 392, 440, 392, 329.63, 261.63];
                let index = 0;
                
                const playNote = () => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.type = 'sine';
                    osc.frequency.value = notes[index];
                    gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.4);
                    
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.4);
                    
                    index = (index + 1) % notes.length;
                };
                
                return setInterval(playNote, 500);
            }
        };
        
        // ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿπÿßŸÑŸÖŸäÿ©
        let scene, camera, renderer;
        let player, bots = [], bullets = [], items = [], buildings = [], trees = [];
        let gameActive = false;
        let currentWeapon = 0;
        let isAiming = false;
        let isFiring = false;
        let kills = 0;
        let zoneRadius = 400;
        let zoneCenter = new THREE.Vector3(0, 0, 0);
        let lastZoneShrink = 0;
        let difficulty = 'medium';
        let selectedSkin = 0;
        
        // ÿ£ÿ≥ŸÑÿ≠ÿ©
        const weapons = [
            { name: 'M416', damage: 35, magSize: 30, fireRate: 100, range: 100, automatic: true },
            { name: 'AKM', damage: 45, magSize: 25, fireRate: 150, range: 80, automatic: true }
        ];
        
        // ÿßŸÑÿ≥ŸÉŸÜÿßÿ™
        const skins = [
            { name: 'Commando', color: 0x2c3e50, secondary: 0xe74c3c },
            { name: 'Desert', color: 0xd4a373, secondary: 0xfaedcd },
            { name: 'Arctic', color: 0xa8dadc, secondary: 0x457b9d }
        ];
        
        // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ¨Ÿàÿ≥ÿ™ŸäŸÉ
        let joystickSize = 100;
        let cameraSensitivity = 5;
        
        // ÿ™ŸáŸäÿ¶ÿ© Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 400);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true,
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            // ÿ•ÿ∂ÿßÿ°ÿ©
            const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 1000;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = 500;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            scene.add(dirLight);
            
            createTerrain();
            createEnvironment();
            setupCharacterPreview();
        }
        
        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ÿ∂ÿßÿ±Ÿäÿ≥
        function createTerrain() {
            // ÿ£ÿ±ÿ∂Ÿäÿ© ŸÖÿπ ÿ™ŸÑÿßŸÑ
            const geometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            const vertices = geometry.attributes.position.array;
            
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                const height = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 10;
                const detail = Math.sin(x * 0.05) * Math.cos(y * 0.05) * 2;
                vertices[i + 2] = height + detail;
            }
            
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x3d5c3d,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = 'ground';
            scene.add(ground);
        }
        
        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ®Ÿäÿ¶ÿ© (ÿ¨ÿ®ÿßŸÑÿå ÿ®ÿ≠Ÿäÿ±ÿ©ÿå ÿ£ÿ¥ÿ¨ÿßÿ±)
        function createEnvironment() {
            // ÿ¨ÿ®ÿßŸÑ
            for (let i = 0; i < 10; i++) {
                const height = 50 + Math.random() * 100;
                const radius = 30 + Math.random() * 50;
                
                const geometry = new THREE.ConeGeometry(radius, height, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x555555,
                    roughness: 0.9
                });
                
                const mountain = new THREE.Mesh(geometry, material);
                const angle = (i / 10) * Math.PI * 2;
                const distance = 400 + Math.random() * 200;
                mountain.position.set(
                    Math.cos(angle) * distance,
                    height / 2 - 10,
                    Math.sin(angle) * distance
                );
                mountain.castShadow = true;
                mountain.receiveShadow = true;
                scene.add(mountain);
            }
            
            // ÿ®ÿ≠Ÿäÿ±ÿ©
            const lakeGeometry = new THREE.CircleGeometry(150, 32);
            const lakeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006994,
                roughness: 0.1,
                metalness: 0.8,
                transparent: true,
                opacity: 0.8
            });
            const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
            lake.rotation.x = -Math.PI / 2;
            lake.position.set(200, 1, 200);
            lake.name = 'water';
            scene.add(lake);
            
            // ÿ£ÿ¥ÿ¨ÿßÿ± ŸàÿßŸÇÿπŸäÿ©
            for (let i = 0; i < 300; i++) {
                createRealisticTree();
            }
            
            // ÿ®ŸäŸàÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿØÿÆŸàŸÑ
            for (let i = 0; i < 25; i++) {
                createEnterableHouse();
            }
            
            // ÿπŸÜÿßÿµÿ± ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂
            for (let i = 0; i < 50; i++) {
                createGroundItem();
            }
        }
        
        // ÿ¥ÿ¨ÿ±ÿ© ŸàÿßŸÇÿπŸäÿ©
        function createRealisticTree() {
            const x = (Math.random() - 0.5) * 1800;
            const z = (Math.random() - 0.5) * 1800;
            
            if (Math.sqrt(x*x + z*z) < 50) return; // ÿßÿ®ÿ™ÿπÿßÿØ ÿπŸÜ ÿßŸÑŸÖÿ±ŸÉÿ≤
            
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // ÿßŸÑÿ¨ÿ∞ÿπ
            const trunkHeight = 4 + Math.random() * 3;
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, trunkHeight, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = trunkHeight / 2;
            trunk.castShadow = true;
            group.add(trunk);
            
            // ÿßŸÑÿ£Ÿàÿ±ÿßŸÇ (ÿ∑ÿ®ŸÇÿßÿ™)
            const layers = 3;
            for (let i = 0; i < layers; i++) {
                const size = 3 - i * 0.5;
                const y = trunkHeight - 1 + i * 1.5;
                
                const leavesGeo = new THREE.ConeGeometry(size, 3, 8);
                const leavesColor = new THREE.Color().setHSL(0.25 + Math.random() * 0.1, 0.8, 0.3);
                const leavesMat = new THREE.MeshStandardMaterial({ color: leavesColor });
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);
                leaves.position.y = y;
                leaves.castShadow = true;
                group.add(leaves);
            }
            
            scene.add(group);
            trees.push(group);
        }
        
        // ÿ®Ÿäÿ™ ŸÇÿßÿ®ŸÑ ŸÑŸÑÿØÿÆŸàŸÑ
        function createEnterableHouse() {
            const x = (Math.random() - 0.5) * 1600;
            const z = (Math.random() - 0.5) * 1600;
            
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // ÿßŸÑÿ¨ÿØÿ±ÿßŸÜ
            const width = 10 + Math.random() * 5;
            const depth = 10 + Math.random() * 5;
            const height = 6;
            
            // ÿßŸÑÿ£ÿ±ÿ∂Ÿäÿ©
            const floorGeo = new THREE.BoxGeometry(width, 0.5, depth);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = 0.25;
            floor.receiveShadow = true;
            group.add(floor);
            
            // ÿßŸÑÿ¨ÿØÿ±ÿßŸÜ ŸÖÿπ ÿ®ÿßÿ®
            const wallThickness = 0.5;
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
            
            // ÿ¨ÿØÿßÿ± ÿÆŸÑŸÅŸä
            const backWall = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, wallThickness),
                wallMat
            );
            backWall.position.set(0, height/2, -depth/2);
            backWall.castShadow = true;
            group.add(backWall);
            
            // ÿ¨ÿØÿßÿ± ÿ£ŸÖÿßŸÖŸä ŸÖÿπ ŸÅÿ™ÿ≠ÿ© ÿßŸÑÿ®ÿßÿ®
            const doorWidth = 2;
            const leftWall = new THREE.Mesh(
                new THREE.BoxGeometry((width - doorWidth) / 2, height, wallThickness),
                wallMat
            );
            leftWall.position.set(-(width + doorWidth) / 4, height/2, depth/2);
            leftWall.castShadow = true;
            group.add(leftWall);
            
            const rightWall = new THREE.Mesh(
                new THREE.BoxGeometry((width - doorWidth) / 2, height, wallThickness),
                wallMat
            );
            rightWall.position.set((width + doorWidth) / 4, height/2, depth/2);
            rightWall.castShadow = true;
            group.add(rightWall);
            
            // ÿ¨ÿßŸÜÿ®ŸäŸÜ
            const leftSide = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, height, depth),
                wallMat
            );
            leftSide.position.set(-width/2, height/2, 0);
            leftSide.castShadow = true;
            group.add(leftSide);
            
            const rightSide = new THREE.Mesh(
                new THREE.BoxGeometry(wallThickness, height, depth),
                wallMat
            );
            rightSide.position.set(width/2, height/2, 0);
            rightSide.castShadow = true;
            group.add(rightSide);
            
            // ÿßŸÑÿ≥ŸÇŸÅ
            const roofHeight = 3;
            const roofGeo = new THREE.ConeGeometry(Math.max(width, depth) * 0.8, roofHeight, 4);
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = height + roofHeight / 2;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);
            
            // ÿßŸÑÿ®ÿßÿ® (ŸÇÿßÿ®ŸÑ ŸÑŸÑŸÅÿ™ÿ≠)
            const doorGeo = new THREE.BoxGeometry(doorWidth, 3.5, 0.2);
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a3728 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 1.75, depth/2);
            door.name = 'door';
            door.userData = { isOpen: false, parent: group };
            group.add(door);
            
            // ŸÜŸàÿßŸÅÿ∞
            for (let i = 0; i < 2; i++) {
                const windowGeo = new THREE.BoxGeometry(2, 2, wallThickness + 0.2);
                const windowMat = new THREE.MeshStandardMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.6
                });
                const window = new THREE.Mesh(windowGeo, windowMat);
                window.position.set(-width/2, height/2, (i === 0 ? -2 : 2));
                group.add(window);
            }
            
            scene.add(group);
            buildings.push(group);
            
            // ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÜÿßÿµÿ± ÿØÿßÿÆŸÑ ÿßŸÑÿ®Ÿäÿ™
            if (Math.random() > 0.3) {
                createWeaponItem(x, 1, z);
            }
            if (Math.random() > 0.4) {
                createHealItem(x + 2, 0.5, z + 2);
            }
        }
        
        // ÿπŸÜÿßÿµÿ± ÿπŸÑŸâ ÿßŸÑÿ£ÿ±ÿ∂
        function createGroundItem() {
            const x = (Math.random() - 0.5) * 1800;
            const z = (Math.random() - 0.5) * 1800;
            
            const type = Math.random();
            if (type < 0.4) {
                createAmmoItem(x, 0.5, z);
            } else if (type < 0.7) {
                createHealItem(x, 0.5, z);
            } else {
                createWeaponItem(x, 1, z);
            }
        }
        
        // ÿ∞ÿÆŸäÿ±ÿ©
        function createAmmoItem(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // ÿµŸÜÿØŸàŸÇ ÿßŸÑÿ∞ÿÆŸäÿ±ÿ©
            const boxGeo = new THREE.BoxGeometry(0.8, 0.4, 0.5);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.castShadow = true;
            group.add(box);
            
            // ÿ∑ŸÑŸÇÿßÿ™ ŸÅŸàŸÇ ÿßŸÑÿµŸÜÿØŸàŸÇ
            for (let i = 0; i < 3; i++) {
                const bulletGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3);
                const bulletMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
                const bullet = new THREE.Mesh(bulletGeo, bulletMat);
                bullet.rotation.z = Math.PI / 2;
                bullet.position.set(0, 0.3 + i * 0.1, 0);
                group.add(bullet);
            }
            
            group.userData = { type: 'ammo', amount: 30 };
            scene.add(group);
            items.push(group);
        }
        
        // ÿπŸÑÿßÿ¨
        function createHealItem(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // ÿπŸÑÿ®ÿ© ÿßŸÑÿ•ÿ≥ÿπÿßŸÅÿßÿ™
            const boxGeo = new THREE.BoxGeometry(0.6, 0.3, 0.4);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const box = new THREE.Mesh(boxGeo, boxMat);
            box.castShadow = true;
            group.add(box);
            
            // ÿπŸÑÿßŸÖÿ© ÿßŸÑÿµŸÑŸäÿ® ÿßŸÑÿ£ÿ≠ŸÖÿ±
            const crossGeo = new THREE.PlaneGeometry(0.4, 0.4);
            const crossMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const cross = new THREE.Mesh(crossGeo, crossMat);
            cross.rotation.x = -Math.PI / 2;
            cross.position.y = 0.16;
            group.add(cross);
            
            group.userData = { type: 'heal', amount: 50 };
            scene.add(group);
            items.push(group);
        }
        
        // ÿ≥ŸÑÿßÿ≠
        function createWeaponItem(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // ÿ®ŸÜÿØŸÇŸäÿ© ŸÖÿ®ÿ≥ÿ∑ÿ©
            const bodyGeo = new THREE.BoxGeometry(0.8, 0.2, 0.15);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.castShadow = true;
            group.add(body);
            
            // ÿßŸÑŸÖÿßÿ≥Ÿàÿ±ÿ©
            const barrelGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.4);
            const barrelMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            const barrel = new THREE.Mesh(barrelGeo, barrelMat);
            barrel.rotation.z = Math.PI / 2;
            barrel.position.set(0.6, 0, 0);
            group.add(barrel);
            
            group.rotation.y = Math.random() * Math.PI;
            group.userData = { type: 'weapon' };
            scene.add(group);
            items.push(group);
        }
        
        // ÿ•ŸÜÿ¥ÿßÿ° ÿ¥ÿÆÿµŸäÿ© ÿ´ŸÑÿßÿ´Ÿäÿ© ÿßŸÑÿ£ÿ®ÿπÿßÿØ ÿ¨ŸÖŸäŸÑÿ©
        function createCharacter(skinId, isPlayer = false) {
            const skin = skins[skinId];
            const group = new THREE.Group();
            
            // ÿßŸÑÿ¨ÿ≥ŸÖ
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.9, 0.35);
            const bodyMat = new THREE.MeshStandardMaterial({ color: skin.color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.35;
            body.castShadow = true;
            group.add(body);
            
            // ÿßŸÑÿµÿØÿ±Ÿäÿ© (vest)
            const vestGeo = new THREE.BoxGeometry(0.65, 0.5, 0.4);
            const vestMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const vest = new THREE.Mesh(vestGeo, vestMat);
            vest.position.y = 0.2;
            body.add(vest);
            
            // ÿßŸÑŸÉÿ™ŸÅ ÿßŸÑÿ£ŸäŸÖŸÜ ÿßŸÑŸÖŸÑŸàŸÜ
            const shoulderGeo = new THREE.BoxGeometry(0.25, 0.25, 0.25);
            const shoulderMat = new THREE.MeshStandardMaterial({ color: skin.secondary });
            const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            rightShoulder.position.set(0.45, 0.3, 0);
            body.add(rightShoulder);
            
            // ÿßŸÑÿ±ÿ£ÿ≥
            const headGeo = new THREE.BoxGeometry(0.35, 0.4, 0.35);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.7;
            body.add(head);
            
            // ÿßŸÑÿÆŸàÿ∞ÿ©
            const helmetGeo = new THREE.BoxGeometry(0.4, 0.15, 0.4);
            const helmetMat = new THREE.MeshStandardMaterial({ color: 0x34495e });
            const helmet = new THREE.Mesh(helmetGeo, helmetMat);
            helmet.position.y = 0.25;
            head.add(helmet);
            
            // ŸÜÿ∏ÿßÿ±ÿ© (ÿßÿÆÿ™Ÿäÿßÿ±Ÿä)
            if (Math.random() > 0.5) {
                const glassesGeo = new THREE.BoxGeometry(0.3, 0.1, 0.1);
                const glassesMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const glasses = new THREE.Mesh(glassesGeo, glassesMat);
                glasses.position.set(0, 0.05, 0.18);
                head.add(glasses);
            }
            
            // ÿßŸÑÿ∞ÿ±ÿßÿπŸäŸÜ
            const armGeo = new THREE.BoxGeometry(0.18, 0.7, 0.18);
            const armMat = new THREE.MeshStandardMaterial({ color: skin.color });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.42, 0, 0);
            body.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.42, 0, 0);
            body.add(rightArm);
            
            // ÿßŸÑÿ≥ŸÑÿßÿ≠
            const gunGroup = new THREE.Group();
            const gunBody = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.12, 0.08),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
            );
            gunGroup.add(gunBody);
            
            const gunBarrel = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.03, 0.3),
                new THREE.MeshStandardMaterial({ color: 0x000000 })
            );
            gunBarrel.rotation.z = Math.PI / 2;
            gunBarrel.position.set(0.5, 0, 0);
            gunGroup.add(gunBarrel);
            
            gunGroup.position.set(0.3, -0.3, 0.3);
            rightArm.add(gunGroup);
            
            // ÿßŸÑÿ≥ÿßŸÇŸäŸÜ
            const legGeo = new THREE.BoxGeometry(0.22, 0.9, 0.22);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.15, -0.9, 0);
            body.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.15, -0.9, 0);
            body.add(rightLeg);
            
            // ÿÆÿµÿßÿ¶ÿµ
            group.userData = {
                isPlayer: isPlayer,
                health: 100,
                armor: 100,
                body: body,
                head: head,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                rightArm: rightArm,
                gun: gunGroup,
                velocity: new THREE.Vector3(),
                isGrounded: true,
                stance: 'stand', // stand, crouch, prone
                ammo: [30, 30],
                totalAmmo: 120,
                lastShot: 0,
                inWater: false
            };
            
            return group;
        }
        
        // ŸÖÿπÿßŸäŸÜÿ© ÿßŸÑÿ¥ÿÆÿµŸäÿ© ŸÅŸä ÿßŸÑŸÑŸàÿ®Ÿä
        function setupCharacterPreview() {
            const canvas = document.getElementById('characterPreview');
            const ctx = canvas.getContext('2d');
            canvas.width = 300;
            canvas.height = 400;
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // ÿÆŸÑŸÅŸäÿ©
                const gradient = ctx.createLinearGradient(0, 0, 0, 400);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.2)');
                gradient.addColorStop(1, 'rgba(118, 75, 162, 0.2)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ÿ±ÿ≥ŸÖ ÿ¥ÿÆÿµŸäÿ© ŸÖÿ®ÿ≥ÿ∑ÿ©
                const skin = skins[selectedSkin];
                
                // ÿßŸÑÿ¨ÿ≥ŸÖ
                ctx.fillStyle = '#' + skin.color.toString(16).padStart(6, '0');
                ctx.fillRect(100, 150, 100, 120);
                
                // ÿßŸÑÿ±ÿ£ÿ≥
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(150, 100, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // ÿßŸÑÿÆŸàÿ∞ÿ©
                ctx.fillStyle = '#34495e';
                ctx.fillRect(110, 65, 80, 25);
                
                // ÿßŸÑŸÉÿ™ŸÅ ÿßŸÑÿ£ŸäŸÖŸÜ ÿßŸÑŸÖŸÑŸàŸÜ
                ctx.fillStyle = '#' + skin.secondary.toString(16).padStart(6, '0');
                ctx.fillRect(180, 160, 30, 30);
                
                // ÿßŸÑÿ≥ŸÑÿßÿ≠
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(180, 200, 80, 15);
                
                requestAnimationFrame(draw);
            }
            draw();
        }
        
        // ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿ≥ŸÉŸÜ
        document.querySelectorAll('.skin-card').forEach((card, index) => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.skin-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                selectedSkin = index;
                setupCharacterPreview();
            });
        });
        
        // ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ©
        function startGame() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('loadingScreen').style.display = 'flex';
            
            AudioEngine.init();
            AudioEngine.playLobbyMusic();
            
            // ŸÖÿ≠ÿßŸÉÿßÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
            let progress = 0;
            const interval = setInterval(() => {
                progress += 5;
                document.getElementById('loadingProgress').style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').style.display = 'none';
                        document.getElementById('gameUI').style.display = 'block';
                        enterGame();
                    }, 500);
                }
            }, 50);
        }
        
        // ÿØÿÆŸàŸÑ ÿßŸÑŸÑÿπÿ®ÿ©
        function enterGame() {
            if (!scene) init();
            
            // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÑÿßÿπÿ®
            const startX = (Math.random() - 0.5) * 100;
            const startZ = (Math.random() - 0.5) * 100;
            player = createCharacter(selectedSkin, true);
            player.position.set(startX, 10, startZ);
            scene.add(player);
            
            // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ®Ÿàÿ™ÿßÿ™
            const botCount = difficulty === 'easy' ? 10 : difficulty === 'medium' ? 15 : difficulty === 'hard' ? 19 : 24;
            for (let i = 0; i < botCount; i++) {
                let x, z;
                do {
                    x = (Math.random() - 0.5) * 1800;
                    z = (Math.random() - 0.5) * 1800;
                } while (Math.sqrt(x*x + z*z) < 200);
                
                const bot = createCharacter(Math.floor(Math.random() * 3), false);
                bot.position.set(x, 10, z);
                bot.userData.ai = {
                    target: null,
                    state: 'idle',
                    lastDecision: 0,
                    accuracy: difficulty === 'easy' ? 0.1 : difficulty === 'medium' ? 0.25 : difficulty === 'hard' ? 0.4 : 0.6,
                    reactionTime: difficulty === 'easy' ? 2000 : difficulty === 'medium' ? 1000 : 500
                };
                scene.add(bot);
                bots.push(bot);
            }
            
            gameActive = true;
            lastZoneShrink = Date.now();
            setupControls();
            animate();
        }
        
        // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÉŸÖ
        let moveVector = { x: 0, y: 0 };
        let lookVector = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };
        
        function setupControls() {
            // ÿßŸÑÿ¨Ÿàÿ≥ÿ™ŸäŸÉ
            const joystick = document.getElementById('moveJoystick');
            const knob = document.getElementById('moveKnob');
            let joystickActive = false;
            let joystickStart = { x: 0, y: 0 };
            
            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                joystickStart.x = rect.left + rect.width / 2;
                joystickStart.y = rect.top + rect.height / 2;
                joystickActive = true;
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });
            
            joystick.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    const touch = e.touches[0];
                    updateJoystick(touch.clientX, touch.clientY);
                }
            }, { passive: false });
            
            joystick.addEventListener('touchend', () => {
                joystickActive = false;
                knob.style.transform = 'translate(-50%, -50%)';
                moveVector = { x: 0, y: 0 };
            });
            
            function updateJoystick(x, y) {
                const maxDist = 50;
                let dx = x - joystickStart.x;
                let dy = y - joystickStart.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > maxDist) {
                    dx = (dx / dist) * maxDist;
                    dy = (dy / dist) * maxDist;
                }
                
                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                
                moveVector.x = dx / maxDist;
                moveVector.y = dy / maxDist;
            }
            
            // ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß (ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ŸäŸÖŸÜ)
            let lookStart = { x: 0, y: 0 };
            let isLooking = false;
            
            document.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                if (touch.clientX > window.innerWidth / 2 && !e.target.closest('.control-btn')) {
                    lookStart.x = touch.clientX;
                    lookStart.y = touch.clientY;
                    isLooking = true;
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (isLooking) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - lookStart.x;
                    const dy = touch.clientY - lookStart.y;
                    
                    cameraRotation.y -= dx * 0.005 * cameraSensitivity;
                    cameraRotation.x -= dy * 0.005 * cameraSensitivity;
                    cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                    
                    lookStart.x = touch.clientX;
                    lookStart.y = touch.clientY;
                }
            }, { passive: false });
            
            document.addEventListener('touchend', () => {
                isLooking = false;
            });
        }
        
        // ÿ≠ŸÑŸÇÿ© ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©
        function animate() {
            if (!gameActive) return;
            requestAnimationFrame(animate);
            
            const delta = 0.016;
            
            updatePlayer(delta);
            updateBots(delta);
            updateBullets(delta);
            updateItems();
            updateZone();
            updateUI();
            
            renderer.render(scene, camera);
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÑÿßÿπÿ®
        function updatePlayer(delta) {
            if (!player) return;
            
            const data = player.userData;
            const speed = data.stance === 'prone' ? 2 : data.stance === 'crouch' ? 4 : 8;
            
            // ÿßŸÑÿ≠ÿ±ŸÉÿ©
            if (moveVector.x !== 0 || moveVector.y !== 0) {
                const forward = new THREE.Vector3(Math.sin(cameraRotation.y), 0, Math.cos(cameraRotation.y));
                const right = new THREE.Vector3(Math.sin(cameraRotation.y + Math.PI/2), 0, Math.cos(cameraRotation.y + Math.PI/2));
                
                const moveDir = new THREE.Vector3()
                    .add(forward.multiplyScalar(-moveVector.y))
                    .add(right.multiplyScalar(moveVector.x));
                moveDir.normalize();
                
                player.position.add(moveDir.multiplyScalar(speed * delta));
                player.rotation.y = cameraRotation.y + Math.PI;
                
                // ÿÆÿ∑Ÿàÿßÿ™
                if (Math.floor(Date.now() / 500) % 2 === 0 && data.isGrounded) {
                    const surface = data.inWater ? 'water' : 'grass';
                    AudioEngine.playFootstep(surface);
                }
                
                // ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ£ÿ±ÿ¨ŸÑ
                const time = Date.now() * 0.01;
                data.leftLeg.rotation.x = Math.sin(time) * 0.5;
                data.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.5;
            } else {
                data.leftLeg.rotation.x = 0;
                data.rightLeg.rotation.x = 0;
            }
            
            // ÿßŸÑÿ¨ÿßÿ∞ÿ®Ÿäÿ© ŸàÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ£ÿ±ÿ∂
            if (player.position.y > 0) {
                data.velocity.y -= 20 * delta;
                player.position.y += data.velocity.y * delta;
                
                if (player.position.y <= 0) {
                    player.position.y = 0;
                    data.velocity.y = 0;
                    data.isGrounded = true;
                }
            }
            
            // ÿßŸÑÿ≥ÿ®ÿßÿ≠ÿ©
            const distToLake = Math.sqrt(
                Math.pow(player.position.x - 200, 2) + 
                Math.pow(player.position.z - 200, 2)
            );
            
            if (distToLake < 150) {
                data.inWater = true;
                if (player.position.y < 2) {
                    player.position.y = 1;
                    data.velocity.y = 0;
                }
            } else {
                data.inWater = false;
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß
            const camDist = isAiming ? 3 : 6;
            const height = isAiming ? 1.5 : 3;
            
            camera.position.x = player.position.x - Math.sin(cameraRotation.y) * camDist;
            camera.position.z = player.position.z - Math.cos(cameraRotation.y) * camDist;
            camera.position.y = player.position.y + height;
            
            camera.lookAt(
                player.position.x + Math.sin(cameraRotation.y) * 10,
                player.position.y + 1.5,
                player.position.z + Math.cos(cameraRotation.y) * 10
            );
            
            // ÿ≥ŸÉŸàÿ®
            if (isAiming) {
                camera.fov = 30;
            } else {
                camera.fov = 75;
            }
            camera.updateProjectionMatrix();
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®Ÿàÿ™ÿßÿ™
        function updateBots(delta) {
            const now = Date.now();
            
            bots.forEach(bot => {
                if (bot.userData.health <= 0) return;
                
                const ai = bot.userData.ai;
                const distToPlayer = bot.position.distanceTo(player.position);
                
                // ÿßÿ™ÿÆÿßÿ∞ ŸÇÿ±ÿßÿ±
                if (now - ai.lastDecision > ai.reactionTime) {
                    ai.lastDecision = now;
                    
                    if (distToPlayer < 50 && Math.random() < 0.7) {
                        ai.target = player;
                        ai.state = 'attack';
                    } else {
                        ai.state = 'wander';
                        ai.wanderTarget = new THREE.Vector3(
                            bot.position.x + (Math.random() - 0.5) * 50,
                            0,
                            bot.position.z + (Math.random() - 0.5) * 50
                        );
                    }
                }
                
                // ÿ™ŸÜŸÅŸäÿ∞
                if (ai.state === 'attack' && ai.target) {
                    const dir = new THREE.Vector3().subVectors(ai.target.position, bot.position).normalize();
                    bot.rotation.y = Math.atan2(dir.x, dir.z);
                    
                    if (distToPlayer > 10) {
                        bot.position.add(dir.multiplyScalar(5 * delta));
                    }
                    
                    // ÿ•ÿ∑ŸÑÿßŸÇ ŸÜÿßÿ±
                    if (now - bot.userData.lastShot > 200 && Math.random() < ai.accuracy) {
                        botShoot(bot);
                        bot.userData.lastShot = now;
                    }
                } else if (ai.state === 'wander') {
                    const dir = new THREE.Vector3().subVectors(ai.wanderTarget, bot.position);
                    if (dir.length() > 1) {
                        dir.normalize();
                        bot.rotation.y = Math.atan2(dir.x, dir.z);
                        bot.position.add(dir.multiplyScalar(3 * delta));
                    }
                }
            });
        }
        
        // ÿ•ÿ∑ŸÑÿßŸÇ ÿßŸÑŸÜÿßÿ±
        function startFiring() {
            isFiring = true;
            fireLoop();
        }
        
        function stopFiring() {
            isFiring = false;
        }
        
        function fireLoop() {
            if (!isFiring || !gameActive) return;
            
            const weapon = weapons[currentWeapon];
            if (player.userData.ammo[currentWeapon] > 0) {
                shoot(player);
                player.userData.ammo[currentWeapon]--;
                AudioEngine.playGunshot();
                
                // ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©
                if (player.userData.ammo[currentWeapon] === 0) {
                    setTimeout(reload, 100);
                }
                
                if (weapon.automatic) {
                    setTimeout(fireLoop, weapon.fireRate);
                }
            }
        }
        
        function botShoot(bot) {
            // ŸÖŸÜÿ∑ŸÇ ÿ•ÿ∑ŸÑÿßŸÇ ŸÜÿßÿ± ÿßŸÑÿ®Ÿàÿ™
        }
        
        function shoot(shooter) {
            const weapon = weapons[currentWeapon];
            const startPos = shooter.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const direction = new THREE.Vector3();
            
            if (shooter.userData.isPlayer) {
                camera.getWorldDirection(direction);
            } else {
                direction.subVectors(player.position, shooter.position).normalize();
            }
            
            // ÿ•ŸÜÿ¥ÿßÿ° ÿ±ÿµÿßÿµÿ© ŸÖÿ±ÿ¶Ÿäÿ©
            const bulletGeo = new THREE.CylinderGeometry(0.02, 0.02, 2);
            const bulletMat = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                emissive: 0xffff00,
                emissiveIntensity: 0.5
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.rotation.z = Math.PI / 2;
            bullet.rotation.y = Math.atan2(direction.x, direction.z);
            bullet.position.copy(startPos);
            bullet.userData = {
                velocity: direction.multiplyScalar(100),
                life: 2,
                damage: weapon.damage,
                shooter: shooter
            };
            scene.add(bullet);
            bullets.push(bullet);
            
            // ÿØÿÆÿßŸÜ
            createMuzzleFlash(startPos);
        }
        
        // ÿØÿÆÿßŸÜ ÿßŸÑÿ®ŸÜÿØŸÇŸäÿ©
        function createMuzzleFlash(pos) {
            const flash = new THREE.PointLight(0xffff00, 1, 5);
            flash.position.copy(pos);
            scene.add(flash);
            setTimeout(() => scene.remove(flash), 50);
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ±ÿµÿßÿµ
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
                bullet.userData.life -= delta;
                
                // ÿßÿµÿ∑ÿØÿßŸÖ
                if (bullet.userData.life <= 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // ÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ£ÿ±ÿ∂
                if (bullet.position.y < 0) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // ÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ£ŸáÿØÿßŸÅ
                const targets = bullet.userData.shooter.userData.isPlayer ? bots : [player];
                for (let target of targets) {
                    if (target.userData.health > 0 && bullet.position.distanceTo(target.position) < 1.5) {
                        takeDamage(target, bullet.userData.damage);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        if (target.userData.isPlayer) {
                            AudioEngine.playHit();
                            showDamageIndicator();
                        }
                        break;
                    }
                }
            }
        }
        
        // ÿ™ŸÑŸÇŸä ÿßŸÑÿ∂ÿ±ÿ±
        function takeDamage(character, amount) {
            character.userData.health -= amount;
            
            if (character.userData.health <= 0) {
                character.userData.health = 0;
                die(character);
            }
        }
        
        // ÿßŸÑŸàŸÅÿßÿ©
        function die(character) {
            character.userData.body.rotation.x = -Math.PI / 2;
            
            if (!character.userData.isPlayer) {
                const index = bots.indexOf(character);
                if (index > -1) bots.splice(index, 1);
                
                kills++;
                showNotification('ŸÇÿ∂Ÿäÿ™ ÿπŸÑŸâ ÿπÿØŸà!');
                AudioEngine.playHit();
            } else {
                endGame(false);
            }
            
            updatePlayerCount();
        }
        
        // ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
        function reload() {
            const weapon = weapons[currentWeapon];
            const needed = weapon.magSize - player.userData.ammo[currentWeapon];
            
            if (needed > 0 && player.userData.totalAmmo >= needed) {
                AudioEngine.playReload();
                player.userData.ammo[currentWeapon] += needed;
                player.userData.totalAmmo -= needed;
                showNotification('ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...');
            }
        }
        
        // ÿ™ÿ®ÿØŸäŸÑ ÿßŸÑÿ≥ŸÑÿßÿ≠
        function switchWeapon() {
            currentWeapon = (currentWeapon + 1) % weapons.length;
            document.getElementById('weaponName').textContent = weapons[currentWeapon].name;
            showNotification(weapons[currentWeapon].name);
        }
        
        // ÿßŸÑŸÇŸÅÿ≤
        function jump() {
            if (player.userData.isGrounded && player.userData.stance !== 'prone') {
                player.userData.velocity.y = 8;
                player.userData.isGrounded = false;
            }
        }
        
        // ÿßŸÑÿ¨ŸÑŸàÿ≥
        function toggleCrouch() {
            if (player.userData.stance === 'crouch') {
                player.userData.stance = 'stand';
                player.userData.body.scale.y = 1;
                player.userData.body.position.y = 1.35;
            } else {
                player.userData.stance = 'crouch';
                player.userData.body.scale.y = 0.6;
                player.userData.body.position.y = 0.8;
            }
        }
        
        // ÿßŸÑÿßŸÜÿ®ÿ∑ÿßÿ≠
        function toggleProne() {
            if (player.userData.stance === 'prone') {
                player.userData.stance = 'stand';
                player.userData.body.rotation.x = 0;
                player.userData.body.position.y = 1.35;
            } else {
                player.userData.stance = 'prone';
                player.userData.body.rotation.x = -Math.PI / 2;
                player.userData.body.position.y = 0.3;
            }
        }
        
        // ÿßŸÑÿ™ÿµŸàŸäÿ®
        function toggleAim() {
            isAiming = !isAiming;
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿπŸÜÿßÿµÿ±
        function updateItems() {
            items.forEach(item => {
                item.rotation.y += 0.02;
                
                // ÿßŸÑÿ™ŸÇÿßÿ∑
                if (item.position.distanceTo(player.position) < 3) {
                    if (item.userData.type === 'ammo') {
                        player.userData.totalAmmo += item.userData.amount;
                        showNotification('+' + item.userData.amount + ' ÿ∞ÿÆŸäÿ±ÿ©');
                        scene.remove(item);
                        items.splice(items.indexOf(item), 1);
                    } else if (item.userData.type === 'heal') {
                        player.userData.health = Math.min(100, player.userData.health + item.userData.amount);
                        AudioEngine.playHeal();
                        showNotification('+' + item.userData.amount + ' ÿµÿ≠ÿ©');
                        scene.remove(item);
                        items.splice(items.indexOf(item), 1);
                    }
                }
            });
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©
        function updateZone() {
            const now = Date.now();
            const elapsed = now - lastZoneShrink;
            const remaining = Math.max(0, 60 - Math.floor(elapsed / 1000));
            document.getElementById('zoneTimer').textContent = remaining;
            
            if (elapsed > 60000) {
                lastZoneShrink = now;
                zoneRadius *= 0.7;
                zoneCenter.x += (Math.random() - 0.5) * 100;
                zoneCenter.z += (Math.random() - 0.5) * 100;
                showNotification('ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ¢ŸÖŸÜÿ© ÿ™ÿ∂ÿßŸÇÿ™!');
                AudioEngine.playExplosion && AudioEngine.playExplosion();
            }
            
            // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑÿµÿ∫Ÿäÿ±ÿ©
            const minimapZone = document.getElementById('minimapZone');
            const scale = 150 / 2000;
            minimapZone.style.width = (zoneRadius * 2 * scale) + 'px';
            minimapZone.style.height = (zoneRadius * 2 * scale) + 'px';
            
            // ÿ∂ÿ±ÿ± ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©
            const distToCenter = player.position.distanceTo(zoneCenter);
            if (distToCenter > zoneRadius) {
                if (Math.random() < 0.05) {
                    takeDamage(player, 2);
                    showNotification('ÿ£ŸÜÿ™ ÿÆÿßÿ±ÿ¨ ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ¢ŸÖŸÜÿ©!');
                }
            }
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸàÿßÿ¨Ÿáÿ©
        function updateUI() {
            if (!player) return;
            
            document.getElementById('currentMag').textContent = player.userData.ammo[currentWeapon];
            document.getElementById('reserveAmmo').textContent = player.userData.totalAmmo;
            document.getElementById('killCount').textContent = kills;
            document.getElementById('healthBar').style.width = player.userData.health + '%';
            
            // ŸÑŸàŸÜ ÿßŸÑÿµÿ≠ÿ©
            const healthFill = document.getElementById('healthBar');
            if (player.userData.health > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #00ff00, #66ff66)';
            } else if (player.userData.health > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #ffff00, #ffcc00)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #ff0000, #ff6666)';
            }
        }
        
        function updatePlayerCount() {
            document.getElementById('playersLeft').textContent = bots.length + 1;
            
            if (bots.length === 0 && player.userData.health > 0) {
                endGame(true);
            }
        }
        
        // ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
        function showNotification(text) {
            const notif = document.getElementById('notification');
            notif.textContent = text;
            notif.style.opacity = 1;
            setTimeout(() => notif.style.opacity = 0, 2000);
        }
        
        // ŸÖÿ§ÿ¥ÿ± ÿßŸÑÿ∂ÿ±ÿ±
        function showDamageIndicator() {
            document.getElementById('gameUI').style.background = 'rgba(255,0,0,0.3)';
            setTimeout(() => {
                document.getElementById('gameUI').style.background = 'transparent';
            }, 100);
        }
        
        // ŸÜŸáÿßŸäÿ© ÿßŸÑŸÑÿπÿ®ÿ©
        function endGame(victory) {
            gameActive = false;
            document.getElementById('endScreen').style.display = 'flex';
            document.getElementById('endTitle').textContent = victory ? 'ÿßŸÜÿ™ÿµÿ±ÿ™!' : 'Ÿáÿ≤ŸÖÿ™';
            document.getElementById('endTitle').className = victory ? 'end-title victory' : 'end-title defeat';
            document.getElementById('endKills').textContent = kills;
        }
        
        // ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ© ÿßŸÑŸÉÿ®Ÿäÿ±ÿ©
        function toggleBigMap() {
            const map = document.getElementById('bigMap');
            if (map.style.display === 'block') {
                map.style.display = 'none';
            } else {
                map.style.display = 'block';
                drawBigMap();
            }
        }
        
        function drawBigMap() {
            const canvas = document.getElementById('bigMapCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // ÿÆŸÑŸÅŸäÿ©
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÿßŸÑŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ¢ŸÖŸÜÿ©
            const scale = Math.min(canvas.width, canvas.height) / 2000;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, zoneRadius * scale, 0, Math.PI * 2);
            ctx.stroke();
            
            // ÿßŸÑŸÑÿßÿπÿ®
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ÿßŸÑÿ®Ÿàÿ™ÿßÿ™
            bots.forEach(bot => {
                const x = centerX + bot.position.x * scale;
                const y = centerY + bot.position.z * scale;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™
        function openSettings() {
            document.getElementById('settings').style.display = 'block';
        }
        
        function closeSettings() {
            document.getElementById('settings').style.display = 'none';
        }
        
        function updateJoystickSize(size) {
            joystickSize = size;
            document.querySelector('.joystick-area').style.width = size + 'px';
            document.querySelector('.joystick-area').style.height = size + 'px';
        }
        
        function updateSensitivity(val) {
            cameraSensitivity = val;
        }
        
        function setDifficulty(diff) {
            difficulty = diff;
        }
        
        function showHowToPlay() {
            alert('ÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑÿ¨Ÿàÿ≥ÿ™ŸäŸÉ ŸÑŸÑŸÖÿ¥Ÿäÿå ÿßŸÑÿ¨ÿßŸÜÿ® ÿßŸÑÿ£ŸäŸÖŸÜ ŸÑŸÑŸÉÿßŸÖŸäÿ±ÿßÿå ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ŸÑŸÑŸÇŸÅÿ≤ ŸàÿßŸÑÿ¨ŸÑŸàÿ≥ ŸàÿßŸÑÿ•ÿ∑ŸÑÿßŸÇ!');
        }
        
        function enterKimMode() {
            alert('KIM Mode Activated! Special Features Unlocked!');
        }
        
        // ŸÖŸÜÿπ ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ≥ŸäÿßŸÇŸäÿ©
        document.addEventListener('contextmenu', e => e.preventDefault());
        
        // ŸÖŸÜÿπ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´ ÿ®ÿßŸÑÿ≥ÿ≠ÿ®
        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>'''

# ÿ≠ŸÅÿ∏ ÿßŸÑŸÖŸÑŸÅ
with open('/mnt/kimi/output/kim_battle_royale_pro.html', 'w', encoding='utf-8') as f:
    f.write(game_html)

print("‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÑÿπÿ®ÿ© ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ÿ®ŸÜÿ¨ÿßÿ≠!")
print(f"üìä ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ: {len(game_html):,} ÿ≠ÿ±ŸÅ")
print("\nüéÆ ÿßŸÑŸÖŸÖŸäÿ≤ÿßÿ™ ÿßŸÑŸÖÿ∂ÿßŸÅÿ©:")
print("- ŸÑŸàÿ®Ÿä ÿßÿ≠ÿ™ÿ±ÿßŸÅŸä ŸÖÿ¥ÿßÿ®Ÿá ŸÑŸÄ PUBG ŸÖÿπ ÿ≤ÿ± KIM Entry")
print("- ÿ£ÿµŸàÿßÿ™ ŸàÿßŸÇÿπŸäÿ© 100% (ÿ•ÿ∑ŸÑÿßŸÇ ŸÜÿßÿ±ÿå ÿÆÿ∑Ÿàÿßÿ™ÿå ÿ•ÿπÿßÿØÿ© ÿ™ÿ≠ŸÖŸäŸÑ)")
print("- 3 ÿ≥ŸÉŸÜÿßÿ™ ÿ¨ŸÖŸäŸÑÿ© ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ±")
print("- ÿ®ŸäŸàÿ™ ŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿØÿÆŸàŸÑ ŸÖÿπ ÿ£ÿ®Ÿàÿßÿ® ŸàŸÜŸàÿßŸÅÿ∞")
print("- ÿ®ÿ≠Ÿäÿ±ÿ© ŸÑŸÑÿ≥ÿ®ÿßÿ≠ÿ© ŸÖÿπ ŸÜÿ∏ÿßŸÖ ÿ≥ÿ®ÿßÿ≠ÿ© ŸÉÿßŸÖŸÑ")
print("- ÿ¨ÿ®ÿßŸÑ ŸàÿßŸÇÿπŸäÿ©")
print("- ŸÜÿ∏ÿßŸÖ ÿ£ÿ≥ŸÑÿ≠ÿ© ŸÖÿ™ŸÇÿØŸÖ (M416 & AKM) ŸÖÿπ ÿ™ÿ®ÿØŸäŸÑ")
print("- ÿ≥ŸÉŸàÿ® ÿ≠ŸÇŸäŸÇŸä (ÿ™ŸÉÿ®Ÿäÿ± ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß)")
print("- ÿ±ÿµÿßÿµ ŸÖÿ±ÿ¶Ÿä ŸÖÿπ ÿØÿÆÿßŸÜ")
print("- ÿÆÿ±Ÿäÿ∑ÿ© ÿµÿ∫Ÿäÿ±ÿ© ÿØÿßÿ¶ÿ±Ÿäÿ© + ÿÆÿ±Ÿäÿ∑ÿ© ŸÉÿ®Ÿäÿ±ÿ©")
print("- ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÉÿßŸÖŸÑÿ© ŸÑŸÑÿ™ÿ≠ŸÉŸÖ")
print("- ŸÅŸäÿ≤Ÿäÿßÿ° ŸÖÿ≠ÿ≥ŸÜÿ© ŸÑŸÖŸÜÿπ ÿØÿÆŸàŸÑ ÿßŸÑÿ£ÿ±ÿ∂")
print("- ÿ∞ŸÉÿßÿ° ÿßÿµÿ∑ŸÜÿßÿπŸä ŸÖÿ™ŸÇÿØŸÖ ŸÑŸÑÿ®Ÿàÿ™ÿßÿ™")
