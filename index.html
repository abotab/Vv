
# Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„ÙƒØ§Ù…Ù„
# Ø³Ø£ÙƒØªØ¨ Ø§Ù„ÙƒÙˆØ¯ ÙÙŠ Ù…Ù„Ù HTML ÙˆØ§Ø­Ø¯ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙƒÙ„ Ø´ÙŠØ¡

game_code = '''<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Battle Royale - Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ù‚Ø§Ø¡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Ø´Ø±ÙŠØ· Ø§Ù„ØµØ­Ø© */
        .health-bar {
            position: absolute;
            bottom: 100px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            transition: width 0.3s;
            width: 100%;
        }
        
        /* Ø§Ù„Ø¹Ø¯Ø§Ø¯ */
        .stats {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        /* Ø§Ù„Ø¯Ø±Ø¯Ø´Ø© */
        .kill-feed {
            position: absolute;
            top: 60px;
            right: 20px;
            color: #ff4444;
            font-size: 14px;
            text-shadow: 1px 1px 2px black;
            max-width: 250px;
        }
        
        /* Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³ */
        .joystick {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.2);
            border: 3px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            pointer-events: auto;
            display: none;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… */
        .control-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.3);
            border: 2px solid rgba(255,255,255,0.6);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 20px;
            backdrop-filter: blur(5px);
        }
        
        #fireBtn {
            bottom: 150px;
            right: 30px;
            background: rgba(255,0,0,0.4);
            width: 80px;
            height: 80px;
        }
        
        #jumpBtn {
            bottom: 50px;
            right: 120px;
        }
        
        #crouchBtn {
            bottom: 50px;
            right: 200px;
        }
        
        #reloadBtn {
            bottom: 250px;
            right: 30px;
        }
        
        /* Ø²Ø± Ø§Ù„ØªÙ‚Ø§Ø· */
        #lootBtn {
            position: absolute;
            bottom: 300px;
            right: 30px;
            background: rgba(0,255,0,0.4);
            display: none;
        }
        
        /* Ø´Ø§Ø´Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .title {
            font-size: 48px;
            color: white;
            font-weight: bold;
            margin-bottom: 30px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        
        .difficulty-select {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .diff-btn {
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: bold;
        }
        
        .diff-btn:hover {
            transform: scale(1.1);
        }
        
        .easy { background: #4CAF50; color: white; }
        .medium { background: #FF9800; color: white; }
        .hard { background: #f44336; color: white; }
        .expert { background: #9C27B0; color: white; }
        
        #startBtn {
            padding: 20px 60px;
            font-size: 24px;
            background: #fff;
            color: #1e3c72;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #startBtn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        /* Ø´Ø§Ø´Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ© */
        #endScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }
        
        .end-title {
            font-size: 64px;
            color: #FFD700;
            margin-bottom: 20px;
        }
        
        .end-stats {
            color: white;
            font-size: 24px;
            margin-bottom: 30px;
        }
        
        #restartBtn {
            padding: 15px 40px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
        }
        
        /* Ø®Ø±ÙŠØ·Ø© ØµØºÙŠØ±Ø© */
        #minimap {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.6);
            border: 2px solid white;
            border-radius: 10px;
        }
        
        /* Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙˆØ§Ù„Ø¹Ø¯Ø§Ø¯Ø§Øª */
        .ammo-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
        }
        
        /* Ù…Ø¤Ø´Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
        }
        
        /* Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… */
        .system-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px black;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div class="stats">
            <div>Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…ØªØ¨Ù‚ÙŠÙ†: <span id="playersCount">16</span></div>
            <div>Ø§Ù„Ù‚ØªÙ„: <span id="kills">0</span></div>
            <div>Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¢Ù…Ù†Ø©: <span id="zoneTimer">60</span>Ø«</div>
        </div>
        
        <div class="kill-feed" id="killFeed"></div>
        
        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>
        
        <div class="ammo-counter">
            <span id="currentAmmo">30</span> / <span id="totalAmmo">120</span>
        </div>
        
        <div id="minimap"></div>
        
        <div class="control-btn" id="fireBtn">ğŸ”¥</div>
        <div class="control-btn" id="jumpBtn">â†—</div>
        <div class="control-btn" id="crouchBtn">ğŸ¦†</div>
        <div class="control-btn" id="reloadBtn">ğŸ”„</div>
        <div class="control-btn" id="lootBtn">ğŸ‘‹</div>
        
        <div class="system-msg" id="systemMsg"></div>
    </div>
    
    <div id="startScreen">
        <div class="title">ğŸ® BATTLE ROYALE</div>
        <div class="difficulty-select">
            <button class="diff-btn easy" onclick="setDifficulty('easy')">Ø³Ù‡Ù„</button>
            <button class="diff-btn medium" onclick="setDifficulty('medium')">Ù…ØªÙˆØ³Ø·</button>
            <button class="diff-btn hard" onclick="setDifficulty('hard')">ØµØ¹Ø¨</button>
            <button class="diff-btn expert" onclick="setDifficulty('expert')">Ø®Ø¨ÙŠØ±</button>
        </div>
        <button id="startBtn" onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
    </div>
    
    <div id="endScreen">
        <div class="end-title" id="endTitle">ğŸ† Ø§Ù†ØªØµØ±Øª!</div>
        <div class="end-stats" id="endStats"></div>
        <button id="restartBtn" onclick="location.reload()">Ù„Ø¹Ø¨ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</button>
    </div>
    
    <div id="loading">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¹Ø§Ù…Ø©
        const CONFIG = {
            MAP_SIZE: 1000,
            BOT_COUNT: 15,
            ZONE_SHRINK_TIME: 60000,
            DIFFICULTY: 'medium',
            GRAVITY: 9.8,
            PLAYER_SPEED: 8,
            BOT_SPEED: 6,
            BULLET_SPEED: 100,
            WEAPON_DAMAGE: 25
        };
        
        let scene, camera, renderer;
        let player, bots = [], items = [], bullets = [], buildings = [];
        let gameActive = false;
        let kills = 0;
        let zoneCenter = new THREE.Vector3(0, 0, 0);
        let zoneRadius = 450;
        let lastZoneShrink = Date.now();
        let difficulty = 'medium';
        
        // Ø£Ù†Ø¸Ù…Ø© Ø§Ù„ØµÙˆØª Ø§Ù„Ø¨Ø±Ù…Ø¬ÙŠØ©
        const AudioSys = {
            ctx: null,
            init: function() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            },
            
            playShoot: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
                
                // ØµØ¯Ù‰ Ø¥Ø¶Ø§ÙÙŠ
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.value = 0.1;
                noise.connect(noiseGain);
                noiseGain.connect(this.ctx.destination);
                noise.start();
            },
            
            playExplosion: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            },
            
            playHit: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },
            
            playFootstep: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.frequency.setValueAtTime(80, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }
        };
        
        // ØªÙ‡ÙŠØ¦Ø© Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 300);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('gameCanvas'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Ø¥Ø¶Ø§Ø¡Ø©
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 200, 100);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -500;
            dirLight.shadow.camera.right = 500;
            dirLight.shadow.camera.top = 500;
            dirLight.shadow.camera.bottom = -500;
            dirLight.shadow.camera.far = 1000;
            scene.add(dirLight);
            
            createTerrain();
            createBuildings();
            
            window.addEventListener('resize', onWindowResize);
            setupMobileControls();
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ¶Ø§Ø±ÙŠØ³
        function createTerrain() {
            // Ø§Ù„Ø£Ø±Ø¶ÙŠØ©
            const groundGeometry = new THREE.PlaneGeometry(CONFIG.MAP_SIZE, CONFIG.MAP_SIZE, 100, 100);
            
            // Ø¥Ø¶Ø§ÙØ© ØªÙ„Ø§Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const y = vertices[i + 1];
                vertices[i + 2] = Math.sin(x * 0.01) * Math.cos(y * 0.01) * 5 + Math.random() * 2;
            }
            groundGeometry.computeVertexNormals();
            
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3d7c3d,
                roughness: 0.8,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Ø£Ø´Ø¬Ø§Ø± ÙˆØµØ®ÙˆØ±
            for (let i = 0; i < 200; i++) {
                createTree();
            }
            for (let i = 0; i < 50; i++) {
                createRock();
            }
            for (let i = 0; i < 100; i++) {
                createGrass();
            }
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¬Ø±Ø©
        function createTree() {
            const x = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            const z = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            
            const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 4, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a2c2a });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, 2, z);
            trunk.castShadow = true;
            
            const leavesGeo = new THREE.ConeGeometry(3, 6, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x0f5f0f });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 5;
            leaves.castShadow = true;
            trunk.add(leaves);
            
            scene.add(trunk);
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ ØµØ®Ø±Ø©
        function createRock() {
            const x = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            const z = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            
            const geo = new THREE.DodecahedronGeometry(Math.random() * 2 + 1, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const rock = new THREE.Mesh(geo, mat);
            rock.position.set(x, 1, z);
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ø´Ø¨
        function createGrass() {
            const x = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            const z = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.9;
            
            const geo = new THREE.PlaneGeometry(0.5, 2);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x4a7c4a, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8
            });
            const grass = new THREE.Mesh(geo, mat);
            grass.position.set(x, 1, z);
            grass.rotation.y = Math.random() * Math.PI;
            scene.add(grass);
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ
        function createBuildings() {
            for (let i = 0; i < 20; i++) {
                const width = Math.random() * 10 + 10;
                const depth = Math.random() * 10 + 10;
                const height = Math.random() * 10 + 5;
                
                const x = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.7;
                const z = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.7;
                
                const geo = new THREE.BoxGeometry(width, height, depth);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.5, 0.5)
                });
                const building = new THREE.Mesh(geo, mat);
                building.position.set(x, height/2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                
                // Ø¥Ø¶Ø§ÙØ© Ø³Ù‚Ù
                const roofGeo = new THREE.ConeGeometry(Math.max(width, depth) * 0.8, 5, 4);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = height/2 + 2.5;
                roof.rotation.y = Math.PI / 4;
                building.add(roof);
                
                scene.add(building);
                buildings.push(building);
                
                // Ø¥Ø¶Ø§ÙØ© Ø£Ø³Ù„Ø­Ø© ÙˆØ¹Ù„Ø§Ø¬Ø§Øª Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ
                if (Math.random() > 0.3) createItem(x, 1, z, 'weapon');
                if (Math.random() > 0.5) createItem(x + 2, 1, z + 2, 'heal');
            }
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø¹Ù†ØµØ± Ù‚Ø§Ø¨Ù„ Ù„Ù„Ø§Ù„ØªÙ‚Ø§Ø·
        function createItem(x, y, z, type) {
            let geo, mat, color;
            if (type === 'weapon') {
                geo = new THREE.BoxGeometry(1, 0.3, 0.3);
                color = 0x333333;
            } else {
                geo = new THREE.CylinderGeometry(0.3, 0.3, 0.8);
                color = 0xff0000;
            }
            
            mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.2 });
            const item = new THREE.Mesh(geo, mat);
            item.position.set(x, y, z);
            item.userData = { type: type, value: type === 'weapon' ? 30 : 50 };
            item.castShadow = true;
            
            // ØªØ£Ø«ÙŠØ± Ø¯ÙˆØ±Ø§Ù†
            item.userData.rotate = true;
            
            scene.add(item);
            items.push(item);
        }
        
        // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø®ØµÙŠØ© (Ù„Ø§Ø¹Ø¨ Ø£Ùˆ Ø¨ÙˆØª)
        function createCharacter(isPlayer = false, x = 0, z = 0) {
            const group = new THREE.Group();
            group.position.set(x, 0, z);
            
            // Ø§Ù„Ø¬Ø³Ù… - Low Poly Ù…Ø´Ø§Ø¨Ù‡ Ù„Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø±ÙÙ‚Ø©
            const bodyGeo = new THREE.BoxGeometry(0.6, 0.8, 0.4);
            const bodyColor = isPlayer ? 0x0066cc : 0xcc0000;
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.4;
            body.castShadow = true;
            group.add(body);
            
            // Ø§Ù„ØµØ¯Ø±ÙŠØ© (Armor)
            const armorGeo = new THREE.BoxGeometry(0.65, 0.5, 0.45);
            const armorMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const armor = new THREE.Mesh(armorGeo, armorMat);
            armor.position.y = 0.1;
            body.add(armor);
            
            // Ø§Ù„ÙƒØªÙ Ø§Ù„Ø£Ø²Ø±Ù‚ (Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©)
            const shoulderGeo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const shoulderMat = new THREE.MeshStandardMaterial({ color: 0x4488ff });
            const rightShoulder = new THREE.Mesh(shoulderGeo, shoulderMat);
            rightShoulder.position.set(0.5, 0.3, 0);
            body.add(rightShoulder);
            
            // Ø§Ù„Ø±Ø£Ø³
            const headGeo = new THREE.BoxGeometry(0.4, 0.45, 0.4);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.7;
            body.add(head);
            
            // Ø§Ù„Ø®ÙˆØ°Ø©
            const helmetGeo = new THREE.BoxGeometry(0.45, 0.2, 0.45);
            const helmetMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const helmet = new THREE.Mesh(helmetGeo, helmetMat);
            helmet.position.y = 0.2;
            head.add(helmet);
            
            // Ø§Ù„Ø°Ø±Ø§Ø¹ÙŠÙ†
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            const armMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            
            const leftArm = new THREE.Mesh(armGeo, armMat);
            leftArm.position.set(-0.45, 0, 0);
            body.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMat);
            rightArm.position.set(0.45, 0, 0);
            body.add(rightArm);
            
            // Ø§Ù„Ø³Ù„Ø§Ø­ ÙÙŠ Ø§Ù„ÙŠØ¯
            const gunGeo = new THREE.BoxGeometry(0.1, 0.1, 0.8);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0, -0.3, 0.4);
            rightArm.add(gun);
            
            // Ø§Ù„Ø³Ø§Ù‚ÙŠÙ†
            const legGeo = new THREE.BoxGeometry(0.22, 0.9, 0.25);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMat);
            leftLeg.position.set(-0.15, -0.9, 0);
            body.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMat);
            rightLeg.position.set(0.15, -0.9, 0);
            body.add(rightLeg);
            
            // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø´Ø®ØµÙŠØ©
            group.userData = {
                isPlayer: isPlayer,
                health: 100,
                maxHealth: 100,
                ammo: 30,
                maxAmmo: 30,
                totalAmmo: 120,
                speed: isPlayer ? CONFIG.PLAYER_SPEED : CONFIG.BOT_SPEED,
                velocity: new THREE.Vector3(),
                isCrouching: false,
                isJumping: false,
                lastShot: 0,
                killCount: 0,
                body: body,
                leftLeg: leftLeg,
                rightLeg: rightLeg,
                rightArm: rightArm,
                head: head
            };
            
            scene.add(group);
            return group;
        }
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨
        function initPlayer() {
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            player = createCharacter(true, x, z);
            camera.position.set(x, 5, z + 10);
            camera.lookAt(x, 0, z);
        }
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¨ÙˆØªØ§Øª
        function initBots() {
            const diffMultiplier = {
                'easy': 0.5,
                'medium': 0.8,
                'hard': 1.2,
                'expert': 1.5
            }[difficulty] || 0.8;
            
            for (let i = 0; i < CONFIG.BOT_COUNT; i++) {
                let x, z;
                do {
                    x = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.8;
                    z = (Math.random() - 0.5) * CONFIG.MAP_SIZE * 0.8;
                } while (x*x + z*z < 400); // Ø§Ø¨ØªØ¹Ø§Ø¯ Ø¹Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨
                
                const bot = createCharacter(false, x, z);
                bot.userData.ai = {
                    target: null,
                    state: 'wander',
                    lastDecision: 0,
                    accuracy: 0.3 * diffMultiplier,
                    reactionTime: 1000 / diffMultiplier,
                    wanderTarget: new THREE.Vector3(x, 0, z)
                };
                bots.push(bot);
            }
        }
        
        // Ø°ÙƒØ§Ø¡ Ø§Ù„Ø¨ÙˆØªØ§Øª
        function updateBots(delta) {
            const now = Date.now();
            
            bots.forEach(bot => {
                if (bot.userData.health <= 0) return;
                
                const ai = bot.userData.ai;
                const pos = bot.position;
                
                // Ø§ØªØ®Ø§Ø° Ù‚Ø±Ø§Ø± Ø¬Ø¯ÙŠØ¯ ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
                if (now - ai.lastDecision > 1000) {
                    ai.lastDecision = now;
                    
                    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‡Ø¯Ù
                    const distToPlayer = pos.distanceTo(player.position);
                    const canSeePlayer = distToPlayer < 50 && Math.random() > 0.3;
                    
                    if (canSeePlayer && player.userData.health > 0) {
                        ai.target = player;
                        ai.state = 'attack';
                    } else if (ai.state === 'attack' && (!canSeePlayer || player.userData.health <= 0)) {
                        ai.state = 'wander';
                        ai.target = null;
                    }
                    
                    // ØªØ­Ø¯ÙŠØ¯ Ù‡Ø¯Ù Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„ØªØ¬ÙˆÙ„
                    if (ai.state === 'wander') {
                        ai.wanderTarget.set(
                            pos.x + (Math.random() - 0.5) * 50,
                            0,
                            pos.z + (Math.random() - 0.5) * 50
                        );
                    }
                }
                
                // ØªÙ†ÙÙŠØ° Ø§Ù„Ø³Ù„ÙˆÙƒ
                if (ai.state === 'attack' && ai.target) {
                    // Ø§Ù„ØªÙˆØ¬Ù‡ Ù†Ø­Ùˆ Ø§Ù„Ù‡Ø¯Ù
                    const targetPos = ai.target.position;
                    const direction = new THREE.Vector3().subVectors(targetPos, pos).normalize();
                    
                    bot.rotation.y = Math.atan2(direction.x, direction.z);
                    
                    // Ø§Ù„ØªÙ‚Ø§Ø·Ø¨
                    if (pos.distanceTo(targetPos) > 10) {
                        bot.position.add(direction.multiplyScalar(bot.userData.speed * delta * 0.5));
                    }
                    
                    // Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
                    if (now - bot.userData.lastShot > 200 + Math.random() * 300) {
                        if (Math.random() < ai.accuracy) {
                            shoot(bot, targetPos);
                        } else {
                            // Ø¥Ø·Ù„Ø§Ù‚ Ø®Ø§Ø·Ø¦
                            const missOffset = new THREE.Vector3(
                                (Math.random() - 0.5) * 5,
                                0,
                                (Math.random() - 0.5) * 5
                            );
                            shoot(bot, targetPos.clone().add(missOffset));
                        }
                        bot.userData.lastShot = now;
                        
                        // ØµÙˆØª Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
                        if (pos.distanceTo(player.position) < 30) {
                            AudioSys.playShoot();
                        }
                    }
                } else if (ai.state === 'wander') {
                    // Ø§Ù„ØªØ¬ÙˆÙ„
                    const dir = new THREE.Vector3().subVectors(ai.wanderTarget, pos);
                    if (dir.length() > 1) {
                        dir.normalize();
                        bot.rotation.y = Math.atan2(dir.x, dir.z);
                        bot.position.add(dir.multiplyScalar(bot.userData.speed * delta * 0.3));
                    }
                }
                
                // ØªØ¬Ù†Ø¨ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¢Ù…Ù†Ø©
                const distFromCenter = Math.sqrt(pos.x * pos.x + pos.z * pos.z);
                if (distFromCenter > zoneRadius) {
                    const toCenter = new THREE.Vector3(0, 0, 0).sub(pos).normalize();
                    bot.position.add(toCenter.multiplyScalar(bot.userData.speed * delta));
                }
                
                // Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø±Ø¬Ù„
                animateCharacter(bot, delta, true);
            });
        }
        
        // Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
        function shoot(shooter, targetPos) {
            if (shooter.userData.ammo <= 0) {
                reload(shooter);
                return;
            }
            
            shooter.userData.ammo--;
            if (shooter.userData.isPlayer) {
                updateUI();
            }
            
            const startPos = shooter.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
            
            // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø·Ù„Ù‚Ø©
            const bulletGeo = new THREE.SphereGeometry(0.05);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            bullet.position.copy(startPos);
            bullet.userData = {
                velocity: direction.multiplyScalar(CONFIG.BULLET_SPEED),
                shooter: shooter,
                damage: CONFIG.WEAPON_DAMAGE
            };
            scene.add(bullet);
            bullets.push(bullet);
            
            // Ø§Ø±ØªØ¯Ø§Ø¯ Ø§Ù„Ø³Ù„Ø§Ø­
            if (shooter.userData.rightArm) {
                shooter.userData.rightArm.rotation.x = -0.3;
                setTimeout(() => {
                    if (shooter.userData.rightArm) {
                        shooter.userData.rightArm.rotation.x = 0;
                    }
                }, 100);
            }
        }
        
        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„
        function reload(character) {
            if (character.userData.totalAmmo > 0 && character.userData.ammo < character.userData.maxAmmo) {
                const needed = character.userData.maxAmmo - character.userData.ammo;
                const available = Math.min(needed, character.userData.totalAmmo);
                character.userData.ammo += available;
                character.userData.totalAmmo -= available;
                
                if (character.userData.isPlayer) {
                    updateUI();
                    showMessage("Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„!");
                }
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø·Ù„Ù‚Ø§Øª
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
                
                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…
                let hit = false;
                
                // Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø£Ø±Ø¶
                if (bullet.position.y < 0) {
                    hit = true;
                }
                
                // Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
                const targets = bullet.userData.shooter.userData.isPlayer ? bots : [player];
                targets.forEach(target => {
                    if (target.userData.health > 0 && bullet.position.distanceTo(target.position) < 1.5) {
                        takeDamage(target, bullet.userData.damage);
                        hit = true;
                        
                        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¯Ù…
                        createBloodEffect(target.position);
                        
                        if (target.userData.isPlayer) {
                            AudioSys.playHit();
                            updateUI();
                        }
                    }
                });
                
                // Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ù…Ø¨Ø§Ù†ÙŠ
                buildings.forEach(building => {
                    if (bullet.position.distanceTo(building.position) < 5) {
                        hit = true;
                    }
                });
                
                if (hit || bullet.position.length() > CONFIG.MAP_SIZE) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        // ØªØ£Ø«ÙŠØ± Ø§Ù„Ø¯Ù…
        function createBloodEffect(position) {
            const particleCount = 5;
            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const particle = new THREE.Mesh(geo, mat);
                particle.position.copy(position);
                particle.position.y += 1;
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 5
                    ),
                    life: 1.0
                };
                scene.add(particle);
                
                // Ø¥Ø²Ø§Ù„Ø© Ø¨Ø¹Ø¯ ÙØªØ±Ø©
                setTimeout(() => scene.remove(particle), 1000);
            }
        }
        
        // ØªÙ„Ù‚ÙŠ Ø§Ù„Ø¶Ø±Ø±
        function takeDamage(character, amount) {
            character.userData.health -= amount;
            
            if (character.userData.health <= 0) {
                character.userData.health = 0;
                die(character);
            }
        }
        
        // Ø§Ù„ÙˆÙØ§Ø©
        function die(character) {
            character.userData.body.rotation.x = -Math.PI / 2;
            
            if (!character.userData.isPlayer) {
                // Ø§Ù„Ø¨ÙˆØª Ù…Ø§Øª
                const index = bots.indexOf(character);
                if (index > -1) {
                    bots.splice(index, 1);
                }
                
                if (character.userData.lastAttacker === player) {
                    kills++;
                    player.userData.totalAmmo += 30;
                    showMessage("Ù‚Ø¶ÙŠØª Ø¹Ù„Ù‰ Ø¹Ø¯Ùˆ! +30 Ø°Ø®ÙŠØ±Ø©");
                    updateUI();
                }
                
                addKillFeed(`ØªÙ… Ø§Ù„Ù‚Ø¶Ø§Ø¡ Ø¹Ù„Ù‰ Ù„Ø§Ø¹Ø¨`);
                
                // Ø¥Ø³Ù‚Ø§Ø· Ø¹Ù†Ø§ØµØ±
                if (Math.random() > 0.5) {
                    createItem(character.position.x, 0.5, character.position.z, 'heal');
                }
            } else {
                // Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø§Øª
                endGame(false);
            }
            
            updatePlayersCount();
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
        function updatePlayersCount() {
            const count = 1 + bots.length;
            document.getElementById('playersCount').textContent = count;
            
            if (count === 1 && player.userData.health > 0) {
                endGame(true);
            }
        }
        
        // Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„Ù‚ØªÙ„
        function addKillFeed(message) {
            const feed = document.getElementById('killFeed');
            const div = document.createElement('div');
            div.textContent = message;
            feed.appendChild(div);
            setTimeout(() => div.remove(), 5000);
        }
        
        // Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø©
        function showMessage(text) {
            const msg = document.getElementById('systemMsg');
            msg.textContent = text;
            msg.style.opacity = 1;
            setTimeout(() => msg.style.opacity = 0, 2000);
        }
        
        // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©
        function animateCharacter(character, delta, isMoving) {
            const time = Date.now() * 0.005;
            
            if (isMoving && character.userData.leftLeg && character.userData.rightLeg) {
                character.userData.leftLeg.rotation.x = Math.sin(time) * 0.5;
                character.userData.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.5;
                
                if (character.userData.isPlayer && time % 1 < 0.1) {
                    AudioSys.playFootstep();
                }
            } else if (character.userData.leftLeg && character.userData.rightLeg) {
                character.userData.leftLeg.rotation.x = 0;
                character.userData.rightLeg.rotation.x = 0;
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¢Ù…Ù†Ø©
        function updateZone() {
            const now = Date.now();
            const elapsed = now - lastZoneShrink;
            const remaining = Math.max(0, Math.ceil((CONFIG.ZONE_SHRINK_TIME - elapsed) / 1000));
            document.getElementById('zoneTimer').textContent = remaining;
            
            if (elapsed > CONFIG.ZONE_SHRINK_TIME) {
                lastZoneShrink = now;
                zoneRadius *= 0.7;
                zoneCenter.x += (Math.random() - 0.5) * 50;
                zoneCenter.z += (Math.random() - 0.5) * 50;
                
                showMessage("Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¢Ù…Ù†Ø© ØªØ¶Ø§Ù‚Øª!");
                AudioSys.playExplosion();
                
                // Ø¶Ø±Ø± Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©
                const distFromCenter = player.position.distanceTo(zoneCenter);
                if (distFromCenter > zoneRadius) {
                    takeDamage(player, 10);
                    updateUI();
                }
            }
            
            // ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©
            // (ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© ØªØ£Ø«ÙŠØ± Ø¨ØµØ±ÙŠ Ù‡Ù†Ø§)
        }
        
        // Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù„Ù…Ø³
        let touchStart = { x: 0, y: 0 };
        let cameraAngle = { x: 0, y: 0 };
        let moveVector = { x: 0, y: 0 };
        let isFiring = false;
        
        function setupMobileControls() {
            const canvas = document.getElementById('gameCanvas');
            
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
            document.getElementById('fireBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                isFiring = true;
                fireContinuous();
            });
            document.getElementById('fireBtn').addEventListener('touchend', () => isFiring = false);
            
            document.getElementById('jumpBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                jump();
            });
            
            document.getElementById('crouchBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleCrouch();
            });
            
            document.getElementById('reloadBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                reload(player);
            });
            
            document.getElementById('lootBtn').addEventListener('touchstart', (e) => {
                e.preventDefault();
                tryLoot();
            });
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStart.x = touch.clientX;
            touchStart.y = touch.clientY;
            
            // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙŠØ³Ø± Ù„Ù„Ø­Ø±ÙƒØ©ØŒ Ø§Ù„Ø£ÙŠÙ…Ù† Ù„Ù„Ø¯ÙˆØ±Ø§Ù†
            if (touch.clientX < window.innerWidth / 2) {
                touchStart.isMove = true;
            } else {
                touchStart.isLook = true;
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (!gameActive) return;
            
            const touch = e.touches[0];
            const dx = touch.clientX - touchStart.x;
            const dy = touch.clientY - touchStart.y;
            
            if (touchStart.isMove) {
                moveVector.x = dx / 50;
                moveVector.y = dy / 50;
            } else if (touchStart.isLook) {
                cameraAngle.y -= dx * 0.005;
                cameraAngle.x -= dy * 0.005;
                cameraAngle.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngle.x));
            }
            
            touchStart.x = touch.clientX;
            touchStart.y = touch.clientY;
        }
        
        function handleTouchEnd(e) {
            if (touchStart.isMove) {
                moveVector.x = 0;
                moveVector.y = 0;
            }
            touchStart.isMove = false;
            touchStart.isLook = false;
        }
        
        function fireContinuous() {
            if (!isFiring || !gameActive) return;
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const target = player.position.clone().add(direction.multiplyScalar(100));
            shoot(player, target);
            AudioSys.playShoot();
            
            setTimeout(fireContinuous, 100);
        }
        
        function jump() {
            if (!player.userData.isJumping) {
                player.userData.velocity.y = 10;
                player.userData.isJumping = true;
            }
        }
        
        function toggleCrouch() {
            player.userData.isCrouching = !player.userData.isCrouching;
            const scale = player.userData.isCrouching ? 0.6 : 1;
            player.userData.body.scale.y = scale;
            player.userData.speed = player.userData.isCrouching ? 4 : 8;
        }
        
        function tryLoot() {
            items.forEach((item, index) => {
                if (item.position.distanceTo(player.position) < 3) {
                    if (item.userData.type === 'weapon') {
                        player.userData.totalAmmo += 30;
                        showMessage("+30 Ø°Ø®ÙŠØ±Ø©");
                    } else if (item.userData.type === 'heal') {
                        player.userData.health = Math.min(player.userData.maxHealth, player.userData.health + 50);
                        showMessage("+50 ØµØ­Ø©");
                    }
                    scene.remove(item);
                    items.splice(index, 1);
                    updateUI();
                }
            });
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨
        function updatePlayer(delta) {
            if (!player || player.userData.health <= 0) return;
            
            // Ø§Ù„Ø­Ø±ÙƒØ©
            const forward = new THREE.Vector3(Math.sin(cameraAngle.y), 0, Math.cos(cameraAngle.y));
            const right = new THREE.Vector3(Math.sin(cameraAngle.y + Math.PI/2), 0, Math.cos(cameraAngle.y + Math.PI/2));
            
            const moveDir = new THREE.Vector3();
            if (moveVector.y < -0.1) moveDir.add(forward);
            if (moveVector.y > 0.1) moveDir.sub(forward);
            if (moveVector.x < -0.1) moveDir.sub(right);
            if (moveVector.x > 0.1) moveDir.add(right);
            
            if (moveDir.length() > 0) {
                moveDir.normalize();
                player.position.add(moveDir.multiplyScalar(player.userData.speed * delta));
                player.rotation.y = cameraAngle.y + Math.PI;
                animateCharacter(player, delta, true);
            } else {
                animateCharacter(player, delta, false);
            }
            
            // Ø§Ù„Ø¬Ø§Ø°Ø¨ÙŠØ©
            if (player.position.y > 0 || player.userData.velocity.y > 0) {
                player.userData.velocity.y -= CONFIG.GRAVITY * delta;
                player.position.y += player.userData.velocity.y * delta;
                
                if (player.position.y <= 0) {
                    player.position.y = 0;
                    player.userData.velocity.y = 0;
                    player.userData.isJumping = false;
                }
            }
            
            // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ (360 Ø¯Ø±Ø¬Ø©)
            const dist = 8;
            camera.position.x = player.position.x - Math.sin(cameraAngle.y) * dist * Math.cos(cameraAngle.x);
            camera.position.y = player.position.y + 3 - Math.sin(cameraAngle.x) * dist;
            camera.position.z = player.position.z - Math.cos(cameraAngle.y) * dist * Math.cos(cameraAngle.x);
            camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);
            
            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø¹Ù†Ø§ØµØ±
            let nearItem = false;
            items.forEach(item => {
                if (item.position.distanceTo(player.position) < 3) {
                    nearItem = true;
                }
            });
            document.getElementById('lootBtn').style.display = nearItem ? 'flex' : 'none';
            
            // Ø§Ù„Ø¶Ø±Ø± Ø®Ø§Ø±Ø¬ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©
            const distFromCenter = player.position.distanceTo(zoneCenter);
            if (distFromCenter > zoneRadius) {
                if (Math.random() < 0.05) {
                    takeDamage(player, 1);
                    updateUI();
                }
            }
        }
        
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
        function updateUI() {
            document.getElementById('healthFill').style.width = player.userData.health + '%';
            document.getElementById('currentAmmo').textContent = player.userData.ammo;
            document.getElementById('totalAmmo').textContent = player.userData.totalAmmo;
            document.getElementById('kills').textContent = kills;
        }
        
        // Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø¹Ù†Ø§ØµØ±
        function rotateItems() {
            items.forEach(item => {
                if (item.userData.rotate) {
                    item.rotation.y += 0.02;
                    item.position.y = 1 + Math.sin(Date.now() * 0.002) * 0.2;
                }
            });
        }
        
        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØµØ¹ÙˆØ¨Ø©
        function setDifficulty(diff) {
            difficulty = diff;
            CONFIG.DIFFICULTY = diff;
        }
        
        // Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            
            AudioSys.init();
            
            setTimeout(() => {
                init();
                initPlayer();
                initBots();
                gameActive = true;
                document.getElementById('loading').style.display = 'none';
                lastZoneShrink = Date.now();
                animate();
            }, 1000);
        }
        
        // Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
        function endGame(victory) {
            gameActive = false;
            document.getElementById('endScreen').style.display = 'flex';
            document.getElementById('endTitle').textContent = victory ? 'ğŸ† Ø§Ù†ØªØµØ±Øª!' : 'â˜ ï¸ Ù‡Ø²Ù…Øª';
            document.getElementById('endStats').textContent = `Ø§Ù„Ù‚ØªÙ„: ${kills} | Ø§Ù„ØµØ­Ø© Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: ${Math.floor(player.userData.health)}`;
        }
        
        // Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
        let lastTime = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            
            if (!gameActive) return;
            
            const delta = (time - lastTime) / 1000 || 0.016;
            lastTime = time;
            
            updatePlayer(delta);
            updateBots(delta);
            updateBullets(delta);
            updateZone();
            rotateItems();
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Ù…Ù†Ø¹ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø³ÙŠØ§Ù‚ÙŠØ©
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>'''

# Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù
with open('/mnt/kimi/output/battle_royale_game.html', 'w', encoding='utf-8') as f:
    f.write(game_code)

print("ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ù†Ø¬Ø§Ø­!")
print("Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù:", len(game_code), "Ø­Ø±Ù")
